import React, { useState } from "react";

// VectorCupComponent.jsx
// Tailwind CSS assumed in the project.
// Обновлён: пустые слои по умолчанию, чашка всегда физически 350мл,
// выбор 250/350 теперь отвечает за уровень заполнения (наполовину / почти полностью).

const ALL_INGREDIENTS = [
  "Эспрессо",
  "Молоко",
  "Сливки",
  "Вода",
  "Пенка",
  "Кокосовый раф",
  "Банановый раф",
  "Клубничный раф",
  "Малиновый раф",
  "Шоколад",
  "Какао",
  "Лёд",
];

function uid() {
  return Math.random().toString(36).slice(2, 9);
}

export default function VectorCupApp() {
  // Фактическая физическая ёмкость и размер стакана — всегда 350 мл
  const PHYSICAL_VOLUME = 350;

  // selectedFill: 250 означает режим "наполовину", 350 — "почти полный"
  const [selectedFill, setSelectedFill] = useState(350);

  // По умолчанию — пусто (без слоёв). Пользователь добавит их сам.
  const [layers, setLayers] = useState([]);
  const [selectedIngredient, setSelectedIngredient] = useState(ALL_INGREDIENTS[0]);

  // Визуальные размеры — всегда для 350 мл (физический стакан)
  const cupInnerHeight = 420; // px высота внутренней области стакана для 350мл
  const cupInnerWidth = 220; // px

  // Наполнение: если пользователь выбрал 250 -> считать как наполовину (0.5), а при 350 -> почти полностью (0.95)
  const fillRatio = selectedFill === 250 ? 0.5 : 0.95;
  const fillHeight = cupInnerHeight * fillRatio;

  function addLayer() {
    setLayers((s) => [...s, { id: uid(), name: selectedIngredient }]);
  }

  function removeLayer(id) {
    setLayers((s) => s.filter((l) => l.id !== id));
  }

  function moveLayer(id, dir) {
    setLayers((s) => {
      const idx = s.findIndex((x) => x.id === id);
      if (idx === -1) return s;
      const newArr = [...s];
      const swapIdx = dir === "up" ? idx - 1 : idx + 1;
      if (swapIdx < 0 || swapIdx >= newArr.length) return s;
      [newArr[idx], newArr[swapIdx]] = [newArr[swapIdx], newArr[idx]];
      return newArr;
    });
  }

  function exportSVG() {
    const svgEl = document.getElementById("vector-cup-svg");
    if (!svgEl) return;
    const clone = svgEl.cloneNode(true);
    const svgString = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `cup_${PHYSICAL_VOLUME}ml_fill${selectedFill}ml.svg`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  const colorFor = (name) => {
    const map = {
      "Эспрессо": "#4B2E2E",
      "Молоко": "#F5EDE6",
      "Сливки": "#FFF7E6",
      "Вода": "#CFE7FF",
      "Пенка": "#FFFFFF",
      "Кокосовый раф": "#F7E9D9",
      "Банановый раф": "#FBE8A6",
      "Клубничный раф": "#FFD0D8",
      "Малиновый раф": "#FFB3C2",
      "Шоколад": "#3E2B2B",
      "Какао": "#6B3F2F",
      "Лёд": "#E6F7FF",
    };
    return map[name] || "#DDDDDD";
  };

  // unitHeight делим только по области заполнения (fillHeight)
  const layerCount = layers.length || 0;
  const unitHeight = layerCount > 0 ? fillHeight / layerCount : 0;

  // SVG размеры
  const svgWidth = 420;
  const svgHeight = cupInnerHeight + 160; // место для тени и бейджа

  // Стили контейнера и небольшие подсказки в UI — правим разметку так, чтобы не "съезжало"
  return (
    <div className="p-6 min-h-screen bg-gray-50">
      <div className="max-w-6xl mx-auto flex gap-8 flex-col md:flex-row">
        {/* Controls */}
        <div className="w-full md:w-96 bg-white p-6 rounded-2xl shadow">
          <h2 className="text-xl font-semibold mb-4">Настройки стакана</h2>

          <div className="mb-4">
            <label className="block text-sm text-gray-600 mb-2">Уровень заполнения</label>
            <div className="flex gap-3">
              <label
                className={`px-3 py-2 rounded-lg cursor-pointer border ${selectedFill === 250 ? 'border-gray-800 bg-gray-100' : 'border-gray-200'}`}
                onClick={() => setSelectedFill(250)}
              >
                Наполовину (250 мл)
              </label>
              <label
                className={`px-3 py-2 rounded-lg cursor-pointer border ${selectedFill === 350 ? 'border-gray-800 bg-gray-100' : 'border-gray-200'}`}
                onClick={() => setSelectedFill(350)}
              >
                Почти полностью (350 мл)
              </label>
            </div>
            <p className="text-xs text-gray-500 mt-2">Примечание: стакан всегда физически 350 мл. Выбор влияет на высоту заполнения.</p>
          </div>

          <div className="mb-4">
            <label className="block text-sm text-gray-600 mb-2">Добавить слой</label>
            <div className="flex gap-2">
              <select
                value={selectedIngredient}
                onChange={(e) => setSelectedIngredient(e.target.value)}
                className="flex-1 border rounded-lg px-3 py-2"
              >
                {ALL_INGREDIENTS.map((ing) => (
                  <option key={ing} value={ing}>
                    {ing}
                  </option>
                ))}
              </select>
              <button className="px-3 py-2 bg-amber-400 rounded-lg" onClick={addLayer}>
                Добавить
              </button>
            </div>
          </div>

          <div>
            <label className="block text-sm text-gray-600 mb-2">Слои ({layerCount})</label>
            <div className="space-y-2 max-h-64 overflow-auto pr-2">
              {layers.length === 0 ? (
                <div className="text-sm text-gray-500 p-3 rounded-lg border">Пусто — добавьте слои через селектор выше.</div>
              ) : (
                layers.map((l, i) => (
                  <div key={l.id} className="flex items-center gap-2 p-2 rounded-lg border">
                    <div className="w-3 h-8 rounded-sm" style={{ background: colorFor(l.name) }} />
                    <div className="flex-1">
                      <div className="font-medium">{l.name}</div>
                      <div className="text-xs text-gray-500">Высота: {Math.round(unitHeight)}px</div>
                    </div>
                    <div className="flex flex-col gap-1">
                      <button onClick={() => moveLayer(l.id, 'up')} className="text-sm p-1 rounded hover:bg-gray-100">▲</button>
                      <button onClick={() => moveLayer(l.id, 'down')} className="text-sm p-1 rounded hover:bg-gray-100">▼</button>
                    </div>
                    <button onClick={() => removeLayer(l.id)} className="text-xs text-red-600 px-2 py-1">Удалить</button>
                  </div>
                ))
              )}
            </div>
          </div>

          <div className="mt-6 flex gap-3">
            <button onClick={exportSVG} className="flex-1 py-2 rounded-lg bg-emerald-500 text-white">Экспортировать SVG</button>
            <button onClick={() => navigator.clipboard && navigator.clipboard.writeText(JSON.stringify(layers))} className="py-2 px-3 rounded-lg border">Копировать JSON</button>
          </div>

          <p className="mt-4 text-xs text-gray-500">SVG экспорт сохраняет вектор — можно открыть в Figma/Illustrator.</p>
        </div>

        {/* Preview */}
        <div className="flex-1 bg-white p-6 rounded-2xl shadow flex flex-col items-center">
          <h3 className="text-lg font-semibold mb-4">Превью стакана</h3>

          <div className="bg-white p-6 rounded-xl w-full flex justify-center">
            <svg
              id="vector-cup-svg"
              width={Math.min(560, svgWidth)}
              height={(Math.min(560, svgWidth) / svgWidth) * svgHeight}
              viewBox={`0 0 ${svgWidth} ${svgHeight}`}
              xmlns="http://www.w3.org/2000/svg"
              preserveAspectRatio="xMidYMin meet"
            >
              <defs>
                <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                  <feDropShadow dx="0" dy="8" stdDeviation="12" floodOpacity="0.12" />
                </filter>

                {/* clipPath — внутренняя область для жидкости (формы бумажного стакана) */}
                <clipPath id="cup-clip">
                  <path d={`M${svgWidth/2 - 110} 80
                              C${svgWidth/2 - 90} 80, ${svgWidth/2 - 70} 80, ${svgWidth/2 + 110} 80
                              L${svgWidth/2 + 90} ${80 + cupInnerHeight}
                              C${svgWidth/2 + 40} ${80 + cupInnerHeight + 18}, ${svgWidth/2 - 40} ${80 + cupInnerHeight + 18}, ${svgWidth/2 - 90} ${80 + cupInnerHeight}
                              Z`} />
                </clipPath>

                {/* Outline path for the paper cup — классическая форма стакана (усечённый конус) */}
                <path id="cup-outline" d={`M${svgWidth/2 - 120} 70
                                              C${svgWidth/2 - 60} 40, ${svgWidth/2 + 60} 40, ${svgWidth/2 + 120} 70
                                              L${svgWidth/2 + 95} ${80 + cupInnerHeight}
                                              C${svgWidth/2 + 50} ${80 + cupInnerHeight + 22}, ${svgWidth/2 - 50} ${80 + cupInnerHeight + 22}, ${svgWidth/2 - 95} ${80 + cupInnerHeight}
                                              Z`} />
              </defs>

              {/* shadow */}
              <ellipse cx={svgWidth / 2} cy={svgHeight - 20} rx={100} ry={14} fill="#000" opacity="0.06" />

              {/* paper cup body */}
              <g>
                <use href="#cup-outline" fill="#fffdf9" stroke="#e7e0d6" strokeWidth={2} filter="url(#shadow)" />

                {/* rim */}
                <ellipse cx={svgWidth/2} cy={82} rx={110} ry={16} fill="#f7f3ef" stroke="#e6ded2" strokeWidth={1} />

                {/* vertical texture */}
                <g opacity={0.06}>
                  {Array.from({length:12}).map((_,i)=>{
                    const x = svgWidth/2 - 100 + i*18;
                    return <rect key={i} x={x} y={90} width={8} height={cupInnerHeight} rx={4} />
                  })}
                </g>

                {/* layers clipped inside */}
                <g clipPath="url(#cup-clip)">
                  {/* base empty area: draw background for full inner area */}
                  <rect x={svgWidth/2 - 110} y={80} width={220} height={cupInnerHeight} fill="transparent" />

                  {/* filled part: compute yStart so that liquids stack from bottom up to fillHeight */}
                  {layerCount === 0 ? null : (
                    (() => {
                      const parts = [];
                      const total = layerCount;
                      for (let i = 0; i < layers.length; i++) {
                        const layer = layers[i];
                        const h = unitHeight;
                        const y = 80 + (cupInnerHeight - fillHeight) + (total - 1 - i) * h; // bottom-up stacking inside clip
                        const color = colorFor(layer.name);
                        parts.push(
                          <g key={layer.id}>
                            <rect x={svgWidth/2 - 110} y={y} width={220} height={h} fill={color} rx={6} />
                            {(layer.name === 'Пенка' || layer.name === 'Молоко') && (
                              <ellipse cx={svgWidth/2} cy={y + 10} rx={80} ry={10} fill="#ffffff" opacity={0.18} />
                            )}
                            {layer.name === 'Лёд' && (
                              <g>
                                {[0,1,2,3].map(n => {
                                  const ix = svgWidth/2 - 90 + (n%2)*60;
                                  const iy = y + 10 + Math.floor(n/2)*34;
                                  return <rect key={n} x={ix} y={iy} width={20} height={20} rx={4} fill="#fff" opacity={0.6} transform={`rotate(-6 ${ix+10} ${iy+10})`} />
                                })}
                              </g>
                            )}
                          </g>
                        );
                      }
                      return parts;
                    })()
                  )}
                </g>

                {/* top soft highlight */}
                <ellipse cx={svgWidth/2} cy={92} rx={100} ry={12} fill="#ffffff" opacity={0.06} />

                {/* outline stroke */}
                <use href="#cup-outline" fill="none" stroke="#d8cfc3" strokeWidth={2} opacity={0.95} />
              </g>

              {/* badge */}
              <g transform={`translate(${svgWidth/2 - 70}, ${svgHeight - 120})`}>
                <rect x={0} y={0} rx={12} width={140} height={54} fill="#fff" stroke="#efe7db" />
                <text x={14} y={26} fontSize={14} fontFamily="sans-serif" fill="#444">{PHYSICAL_VOLUME} мл</text>
                <text x={14} y={44} fontSize={12} fontFamily="sans-serif" fill="#666">{layers.length} слоёв</text>
              </g>
            </svg>
          </div>

          <div className="mt-5 text-sm text-gray-600">Сделано как вектор — можно экспортировать для Figma / Illustrator.</div>
        </div>
      </div>

      <div className="max-w-6xl mx-auto mt-6 text-xs text-gray-500">Подсказки: стакан — всегда 350 мл физически. Выбор 250/350 влияет только на высоту заполнения (наполовину / почти полный). Экспорт SVG сохраняет текущий вид.</div>
    </div>
  );
}
